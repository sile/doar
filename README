[概要]
Doarは、DoubleArrayの構築・検索を行うためのC++ライブラリです。

現在(2009/10/08)で実装されている機能は以下の通りです。
 ・ソート済みのキーセットから、DoubleArrayを構築し、ファイルに保存する
 ・上で作成したDoubleArrayデータから、キーを検索する
 ・各キーを、0から始まるユニークなIDにマッピング


[環境]
・現在(2009/10/08)は、unix,32bit(sizeof(int)==4)、環境を前提としています


[使い方]
・makeでサンプルコマンドをコンパイル
　・mkdoar:    DoubleArray構築コマンド
　・doar:      簡易検索コマンド (通常検索, common-prefix検索)
　・doar_test: 構築したDoubleArrayのテスト & ベンチマークコマンド
・具体的な使い方は、src/comman/以下のファイルを参照してください


[簡易API]
namespace Doar {
  //=== ファイル: src/doar/builder.h ===
  class Builder {
    // 引数のファイル(ソート済み)から、DoubleArrayを構築する
    bool build(const char* filepath);
    // 引数の文字列配列(ソート済み)から、DoubleArrayを構築する
    bool build(const char** strs, unsigned str_count);
    
    // 引数のファイルにDoubleArrayを保存する
    bool save(const char* filepath);    
  };

  //=== ファイル: src/doar/node.h ===
  struct Node {
    // IDを取得する
    unsigned id() const;

    // ノードが有効化どうかを返す
    bool valid() const;

    // ノードが葉(終端)かどうかを返す
    bool is_leaf() const;
  }

  //=== ファイル: src/doar/searcher.h ===
  class Searcher {
    // DoubleArrayを引数のファイルから読み込む
    Searcher(cosnt char* filepath);

    // DoubleArrayに格納されているキー数を取得する
    unsigned size() const;

    // ルートノードを取得する
    Node root_node() const;

    // キーに対応するノードを探す
    // 検索に失敗した場合は、Node.valid()==falseとなる
    Node search(const char* key) const;

    // 初期ノード(root_node)を指定して、検索を行う
    // root_nodeには、最後に使われた親ノードが格納される
    Node search(const char* key, Node &root_node) const;

    // common-prefix検索を行う
    // 初期ノード(root_node)およびキーの検索開始位置(offset)を指定して、common-prefix検索を行う
    // キーの途中で一致するノードがあった場合は、検索は中断され、そのノードが返される
    // offsetには最後に使われたキーの位置が、root_nodeには最後に使われた親ノードが、格納される
    // ※ searchメソッドとは異なり、空文字列に対する検索は常に失敗する。(= 最低でも一文字以上一致する必要がある。)
    Node common_prefix_search(const char* key, unsigned& offset, Node& root_node) const;
    
    // parentの子ノード(のindex)を、resultに集める
    void children(Node parent, NodeIndexList& result) const;
    
    // idxから(遷移)文字を取得する
    char get_arc(NodeIndex idx) const;
    // idxからNodeを取得する
    Node get_node(NodeIndex idx) const;
  };
}


[TODO]
・要素の動的更新(追加・削除)に対応  ※ namespaceは現状のものとは分ける?
・ポータビリティ向上